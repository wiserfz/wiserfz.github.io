<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://wiserfz.github.io name=base><title>
            
                memory profiling for rust
            
        </title><meta content="memory profiling for rust" property=og:title><meta content="Rust program memory profiling with heaptrack." property=og:description><meta content="Rust program memory profiling with heaptrack." name=description><link href=https://wiserfz.github.io/img/favicons/favicon.ico rel=icon type=image/png><link href=https://wiserfz.github.io/fonts.css rel=stylesheet><script defer src=https://wiserfz.github.io/js/codeblock.js></script><script defer src=https://wiserfz.github.io/js/toc.js></script><script>MathJax = {
                    tex: {
                        inlineMath: [
                            ['$', '$'],
                            ['\\(', '\\)']
                        ]
                    }
                };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link title="
    wiser's blog
" href=https://wiserfz.github.io/atom.xml rel=alternate type=application/atom+xml><link title="
    wiser's blog
" href=https://wiserfz.github.io/rss.xml rel=alternate type=application/rss+xml><link href=https://wiserfz.github.io/theme/light.css rel=stylesheet><link href=https://wiserfz.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://wiserfz.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://wiserfz.github.io/main.css media=screen rel=stylesheet><script src="https://wiserfz.github.io/search_index.en.js?h=83f808dfc552363cb1ef" defer></script><script src="https://wiserfz.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=left-content></div><div class=content><nav><div class=left-nav><a href=https://wiserfz.github.io>wiser's blog</a><div class=socials><a rel="'me" target="'_blank'" class=social href=https://wiserfz.github.io/rss.xml noopener&#x27;> <img alt=rss src=https://wiserfz.github.io/icons/social/rss.svg> </a><a rel="'me" target="'_blank'" class=social href=mailto:wiserfz810@gmail.com noopener&#x27;> <img alt=email src=https://wiserfz.github.io/icons/social/email.svg> </a><a rel="'me" target="'_blank'" class=social href=https://github.com/wiserfz/ noopener&#x27;> <img alt=github src=https://wiserfz.github.io/icons/social/github.svg> </a></div></div><div class=right-nav><a href=https://wiserfz.github.io style=margin-right:.5em>/home</a><a href=https://wiserfz.github.io/posts style=margin-right:.5em>/posts</a><a href=https://wiserfz.github.io/tags style=margin-right:.5em>/tags</a><a href=https://wiserfz.github.io/about style=margin-right:.5em>/about</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://wiserfz.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://wiserfz.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://wiserfz.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>memory profiling for rust</div><div class=meta>Posted on <time>2024-05-03</time><span class=tags-label>::</span><span class=tags> <a class=post-tag href=https://wiserfz.github.io/tags/profiling/>profiling</a> <a class=post-tag href=https://wiserfz.github.io/tags/heap/>heap</a> </span></div></div><section class=body><h2 id=overview><a aria-label="Anchor link for: overview" class=zola-anchor href=#overview>Overview</a></h2><p>由于线上某个服务经常出现崩溃并且还会造成雪崩效应，每次出现故障后，不得不立即采取扩容2倍机器的方式来解决故障；并且 review 该服务的代码后，发现逻辑混乱，错误处理缺失，没有相应的日志信息等等问题；因此决定对该服务进行重构，利用 rust 重写，并解决程序容易崩溃，问题不好排查等等线上问题。<p>重构后，在 2C4G 上的机器进行基准测试后发现，重构后的服务最多只能承载 3000 左右的设备连接；但是，旧的服务可以轻松承载 4w 以上的设备连接，因此需要对代码进行 memory profiling，对代码进行优化解决内存不足的问题。<h2 id=heaptrack><a aria-label="Anchor link for: heaptrack" class=zola-anchor href=#heaptrack>Heaptrack</a></h2><p><a href=https://github.com/KDE/heaptrack rel=noopener target=_blank>Heaptrack</a> 是一个强大的 Linux 的堆内存分析工具，它可以帮助我们：<ul><li>找到需要优化的热点，并减少应用程序的内存占用<li>找出内存泄漏<li>找出内存分配的热点<li>找出临时分配的内存</ul><p>具体可以参考这篇博客<sup class=footnote-reference><a href=#1>1</a></sup>，这里详细介绍了 heaptrack。<h2 id=profiling><a aria-label="Anchor link for: profiling" class=zola-anchor href=#profiling>Profiling</a></h2><p>对一个 release build 的 rust 程序进行 profiling，首先需要开启 <code>debug info</code>，在 <code>Cargo.toml</code> 中添加以下配置：<pre class=language-toml data-lang=toml style=color:#c0c5ce;background-color:#2b303b><code class=language-toml data-lang=toml><span>[profile.release]
</span><span style=color:#bf616a>debug </span><span>= </span><span style=color:#d08770>1
</span></code></pre><p>可以在 Cargo book 的 Profiles<sup class=footnote-reference><a href=#2>2</a></sup> 参考更多配置。<p>如果，想要对 rust 标准库的代码进行 profiling，那么以上的配置还是不够的。因为 rust 的标准库不是通过 debug info 进行构建的。因此，如果想要对标准库中的代码进行 profiling，通常我们需要通过 rust 的原码构建自己的编译器，并且在 <code>config.toml</code> 中添加以下配置：<pre class=language-toml data-lang=toml style=color:#c0c5ce;background-color:#2b303b><code class=language-toml data-lang=toml><span>[rust]
</span><span style=color:#bf616a>debuginfo-level </span><span>= </span><span style=color:#d08770>1
</span></code></pre><p>不过，rust 的原码的性能都是极好的可以参考标准库的引导<sup class=footnote-reference><a href=#3>3</a></sup> 自己进行测试也可以参考这个结果<sup class=footnote-reference><a href=#4>4</a></sup>。<p>构建好程序后，需要在 linux 平台上运行，无论是通过 <code>heaptrack &lt;your application and its parameters></code> 还是通过 attach 的方式 <code>heaptrack --pid $(pidof &lt;your application>)</code>；最终都会得到一个 <code>gz</code> 后缀文件的结果，可以通过 <code>heaptrack_gui</code> 程序解析这个文件并得到火焰图。<h2 id=heaptrack-gui><a aria-label="Anchor link for: heaptrack-gui" class=zola-anchor href=#heaptrack-gui>heaptrack_gui</a></h2><p>通过原码构建的方式<sup class=footnote-reference><a href=#5>5</a></sup>编译得到 heaptrack_gui，推荐通过 homebrew 的方式进行安装。<p><img alt="Flame Graph" src=/img/heaptrack-rust/heaptrack-flame-graph.png><p>通过上述火焰图，得出 <a href=https://docs.rs/rumqttc/latest/rumqttc/struct.MqttState.html rel=noopener target=_blank>rumqttc::MqttState</a> 在初始化时占用大量内存。<pre class=language-rs data-lang=rs style=color:#c0c5ce;background-color:#2b303b><code class=language-rs data-lang=rs><span style=color:#65737e>/// Creates new mqtt state. Same state should be used during a
</span><span style=color:#65737e>/// connection for persistent sessions while new state should
</span><span style=color:#65737e>/// instantiated for clean sessions
</span><span style=color:#b48ead>pub fn </span><span style=color:#8fa1b3>new</span><span>(</span><span style=color:#bf616a>max_inflight</span><span>: </span><span style=color:#b48ead>u16</span><span>, </span><span style=color:#bf616a>manual_acks</span><span>: </span><span style=color:#b48ead>bool</span><span>) -> </span><span style=color:#b48ead>Self </span><span>{
</span><span>    MqttState {
</span><span>        await_pingresp: </span><span style=color:#d08770>false</span><span>,
</span><span>        collision_ping_count: </span><span style=color:#d08770>0</span><span>,
</span><span>        last_incoming: Instant::now(),
</span><span>        last_outgoing: Instant::now(),
</span><span>        last_pkid: </span><span style=color:#d08770>0</span><span>,
</span><span>        last_puback: </span><span style=color:#d08770>0</span><span>,
</span><span>        inflight: </span><span style=color:#d08770>0</span><span>,
</span><span>        max_inflight,
</span><span>        </span><span style=color:#65737e>// index 0 is wasted as 0 is not a valid packet id
</span><span>        outgoing_pub: vec![None; max_inflight as </span><span style=color:#b48ead>usize </span><span>+ </span><span style=color:#d08770>1</span><span>], </span><span style=color:#65737e>// max_inflight default 100
</span><span>        outgoing_rel: vec![None; max_inflight as </span><span style=color:#b48ead>usize </span><span>+ </span><span style=color:#d08770>1</span><span>],
</span><span>        incoming_pub: vec![None; std::u16::</span><span style=color:#d08770>MAX </span><span>as </span><span style=color:#b48ead>usize </span><span>+ </span><span style=color:#d08770>1</span><span>],
</span><span>        collision: None,
</span><span>        </span><span style=color:#65737e>// TODO: Optimize these sizes later
</span><span>        events: VecDeque::with_capacity(</span><span style=color:#d08770>100</span><span>),
</span><span>        write: BytesMut::with_capacity(</span><span style=color:#d08770>10 </span><span>* </span><span style=color:#d08770>1024</span><span>),
</span><span>        manual_acks,
</span><span>    }
</span><span>}
</span></code></pre><p>在初始化 <code>MqttState</code> 时；大概需要分配 300 Kb 内存，以下为字段所占内存计算：<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>outgoing_pub:</span><span> 144 * 101 = 14544 bytes
</span><span style=color:#bf616a>outgoing_rel:</span><span> 4 * 101 = 404 bytes
</span><span style=color:#bf616a>incomeing_pub:</span><span> 4 * 65536 = 262144 bytes
</span><span style=color:#bf616a>events:</span><span> 144 * 100 = 14400 bytes
</span><span style=color:#bf616a>write:</span><span> 10240 bytes
</span><span>
</span><span style=color:#bf616a>total:</span><span> 301732 bytes
</span></code></pre><p>与基准测试的数据基本符合，因此；定位到问题是由于构建 MQTT client 对象时，分配的内存过多导致的内存使用过高。<p>经过上述分析，最终通过复用 <code>rumqttc</code> 库的 codec 实现自己的 MQTT client 解决内存占用过大的问题。<h2 id=reference><a aria-label="Anchor link for: reference" class=zola-anchor href=#reference>Reference</a></h2><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>https://milianw.de/blog/heaptrack-a-heap-memory-profiler-for-linux.html</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>https://doc.rust-lang.org/cargo/reference/profiles.html</div><div class=footnote-definition id=3><sup class=footnote-definition-label>3</sup><p>https://std-dev-guide.rust-lang.org/development/perf-benchmarking.html</div><div class=footnote-definition id=4><sup class=footnote-definition-label>4</sup><p>https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html</div><div class=footnote-definition id=5><sup class=footnote-definition-label>5</sup><p>https://github.com/KDE/heaptrack#heaptrack_gui-dependencies</div></section></article></main></div></div><div class=right-content><div class=toc><div class=heading>Table of Contents</div><ul class=toc-list><li class=parent><a href=https://wiserfz.github.io/posts/memory-profiling-for-rust/#overview>Overview</a><li class=parent><a href=https://wiserfz.github.io/posts/memory-profiling-for-rust/#heaptrack>Heaptrack</a><li class=parent><a href=https://wiserfz.github.io/posts/memory-profiling-for-rust/#profiling>Profiling</a><li class=parent><a href=https://wiserfz.github.io/posts/memory-profiling-for-rust/#heaptrack-gui>heaptrack_gui</a><li class=parent><a href=https://wiserfz.github.io/posts/memory-profiling-for-rust/#reference>Reference</a></ul></div></div>